---
title: "ggvega"
subtitle: "ggplot2 to Vega-Lite translator"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "extra-theme.css"]
    nature:
      ratio: "16:9"
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
options(htmltools.dir.version = FALSE)
library(tidyverse)
# install_github("hadley/emo")
# library(emo)
# emo_heart_eyes <- emo::ji("smiling face with heart-eyes")
library(ggvega)
cars <- jsonlite::fromJSON("https://vega.github.io/vega-lite/data/cars.json")
```

### ggvega

Created to translate from ggplot2 to Vega-Lite  

- inspired by the capability `plotly::ggplotly()` provides 

.pull-left[

```{r echo=FALSE, fig.width=5, fig.height=4}
p <- ggplot(cars, aes(x = Horsepower, y = Miles_per_Gallon)) +
  geom_point(aes(color = Origin)) 

p
```
]
.pull-right[
```{r echo=FALSE, fig.asp=.65}
p <- ggplot(cars, aes(x = Horsepower, y = Miles_per_Gallon)) +
  geom_point(aes(color = Origin)) 

as_vegaspec(p)
```
]



.center[
<br/><br/><br/>
**(add visual of ggplot2 -> vl)**
]

.footnote[
This project has been supported by Iowa State University, Schneider Electric, and GSOC.
]

---
class: inverse, center, middle
# Motivation

---
### Goals

#### ggplot2 + interactivity


#### build & deploy visual components (in JS and HTML) 


- extensible to new data  

  - a guiding principle when making fundamental design choices

  - distinguishes this effort from `plotly::ggplotly()`

--

> Compared to `plot_ly()`, statistical queries (client-side) with `ggplotly()` are fundamentally limited. That’s because, the statistical R functions that ggplot2 relies on to generate the graphical layers can’t necessarily be recomputed with different input data in your web browser.

---
### Goals

#### ggplot2 + interactivity

#### build & deploy visual components (in JS and HTML) 


- extensible to new data  

  - a guiding principle when making fundamental design choices

  - distinguishes this effort from `plotly::ggplotly()`

.center[
<br/><br/><br/>
**(example with update-able data??)**
]

???

---
### ggplot2 + interactivity

Our requirements for the JavaScript library:

  - has the grammar of graphics at its foundation  
  
  - is open source  
  
  - is easy to use  
  
  - is able to be linked with other preexisting htmlwidgets  
  
  - can be tied to ggplot2  

---
### Vega + Vega-Lite


Designed to be a visualization grammar that is built for analysis

Both Vega and Vega-lite use a JSON specification to create a visualization, with Vega-lite first compiling to
Vega and then rendered using Vega’s compiler.

An implementation of visualization terms with the
**grammar of graphics** at its core

---
class: inverse, center, middle
# Grammar of Graphics

---
.left-third2[
<!-- <img src="dsc_files/ggplot2.png" height="100"> -->

#### A layered Grammar

<!-- Four basic components that form a layer: -->

<br />

.salt[
data
]
.fat[
stat
]
.acid[
mapping
]
.heat[
geom
]
].left-third2[

#### Vega-Lite’s relation to ggplot2
<!-- <img src="dsc_files/vl2.png" height="100">

Four basic components that ... -->

<br />

.salt[
data
]
.fat[
transform
]
.acid[
encoding
]
.heat[
mark
]

].right-third2[

#### Grammar-of-Graphics as Food

<br />
<!-- <img src="dsc_files/ggfood2.png" height="100"> -->

<!-- Four basic factors that determine how good your food will taste: -->

.salt[
salt
]
.fat[
fat
]
.acid[
acid
]
.heat[
heat
]

]

---
class: inverse, center, middle
# ggvega

---
### Motivating use-case for ggvega

#### A data-scientist designs a visualization using R with ggplot2  

#### The ggplot2 object is translated to a Vega-Lite specification (using ggvega)  

#### The Vega-Lite specification can be deployed to production, independently of the data used to design it. 

#### Vega provides the means to update Vega views with new data.


---
class: inverse, center, middle
# Design Philosophy

---
### Fundamental design choices


<br/>

**Our initial philosophy:** A narrow scope built on a firm foundation.

<br/>

**Design choice #1:** intention vs. implementation?

???

ggvega seeks to capture the *intent* of a ggplot. This is distinct from the *implementation* of a ggplot (the path `ggplotly()` takes). Our idea is to let the powerful defaults of the two packages take care of most of the work. In addition, we anticipated (at some point in the (hopefully not-too-)distant future) creating a Vega-lite theme for the visual components.

---
### Our approach

#### A 2 step process:

1. Convert a ggplot2 object into a "ggspec", a JSON-serializable list  

2. Convert a "ggspec" into a Vega-Lite specification or "vegaspec".

<br/>
<br/>

.center[
.salt[ggplot2 ].fat[ -> ].acid[ ggspec ].fat[ -> ].heat[ vlspec]
]

???

#### Why 2 steps? 

- We hope that the ggspec can be a useful abstraction to help us understand  "what is going on in ggplot2?" and "how does this intersect with Vega-Lite?". 

- Should ggplot2 or Vega-Lite change, we hope that we could keep ggspec "fixed" such that we would have to adapt only that part of the translation process (ggplot2-to-ggspec or ggspec-to-Vega-Lite) that would be impacted by such a change.

---
.salt[ggplot2 ].fat[ -> ].acid[ ggspec ]

<br/>

The ideas for "ggspec" are 

- to remain faithful to the ggplot2 object and philosophy

- to publish a JSON schema that represents the range of "things" that we will be able to translate

- to provide the means to generate a JSON specification that meets this schema, given a ggplot2 object

<br/>

???

The ggspec should record only those things that deviate from ggplot2 defaults; one should be able to take a ggspec and recreate the ggplot object that it came from.

Accordingly, we think to specify things in Vega-Lite only as they differ from the Vega-Lite defaults. Our goal is to capture the “essence” of the ggplot, its intentions, then to implement in a default Vega-Lite specification. To replicate the default color-maps and appearance, we recommend using a Vega theme (we hope to propose a better ggplot2-theme for Vega).




---
.salt[ggplot2 ].fat[ -> ].acid[ ggspec ]


.pull-left[

```{r fig.asp=.65}
p <- ggplot(cars, aes(x = Horsepower, y = Miles_per_Gallon)) +
  geom_point(aes(color = Origin)) 

p
```

]
.pull-right[


```{r eval=FALSE}
ggvega::gg2spec(p)
```

```json
{
  "data": {
    "data-00": {
      "metadata": {},
      "observations": []
    }
  },
  "layers": [
    {
      "data": "data-00",
      "geom": {},
      "geom_params": {},
      "mapping": {},
      "aes_params": {},
      "stat": {},
      "stat_params": {},
      "position": {}
    }
  ],
  "scales": [],
  "labels": {},
  "coordinates": {},
  "facet": {}
}
```
]

---


.left-minus-tall[
<br/>
<img src="dsc_files/ideal_vs_real.jpg" width="400"> 
]
.right-plus-tall[
### Idealized vs. Actualized

**Idealized version:**   
- a JSON-serializable representation of any possible ggplot object;  

- that it could also be a loss-less representation of any ggplot object.  

**Actualized version:**
- *is* a JSON-serializable representation of a ggplot object that we can translate into Vega-Lite.

<!--
In an ideal world, we might have taken on the **idealized** ggspec, then defined an **actualized** subset. 

However, in the interests of "getting something done", we considered briefly the first possibility, then went straight for the second possibility. 

-->

]

---
.acid[ ggspec ].fat[ -> ].heat[ vlspec]

<br/>

The ggspec is then converted into a vegaspec. 

As a first approach, we took inspiration from Vega-Lite itself, which translates a Vega-Lite specification into a Vega specification. 

This compiler is developed in TypeScript, then compiled into ECMAScript 6 (JavaScript), as described in the [Vega-Lite contribution guide](https://github.com/vega/vega-lite/blob/master/CONTRIBUTING.md#suggested-programming-environment).


---
.acid[ ggspec ].fat[ -> ].heat[ vlspec]

.pull-left[


```{r eval=FALSE}
ggvega::gg2spec(p)
```

```json
{
  "data": {
    "data-00": {
      "metadata": {},
      "observations": []
    }
  },
  "layers": [
    {
      "data": "data-00",
      "geom": {},
      "geom_params": {},
      "mapping": {},
      "aes_params": {},
      "stat": {},
      "stat_params": {},
      "position": {}
    }
  ],
  "scales": [],
  "labels": {},
  "coordinates": {},
  "facet": {}
}
```
]
.pull-right[
```{r eval = FALSE}
ggvega::as_vegaspec(p)
```


```json
{
  "$schema": "https://vega.github.io/schema/vega-lite/v3.json",
  "datasets": {
    "data-00": []
  },
  "layer": [
    {
      "data": {},
      "mark": {},
      "encoding": {
        "x": {},
        "y": {},
        "stroke": {}
      }
    }
  ]
}
```
]


---
class: inverse, center, middle
# Examples

---
### ggvega


.pull-left[

```{r eval=FALSE}
library("ggplot2")
library("ggvega")


plot <- ggplot(iris) + 
  geom_point(aes(x = Petal.Width, y = Petal.Length, 
                 colour = Species))

as_vegaspec(plot)
  

```

]

.pull-right[

```{r message=FALSE, warning=FALSE, echo=FALSE}
library("ggplot2")
library("ggvega")
plot <- ggplot(iris) + 
  geom_point(aes(x = Petal.Width, y = Petal.Length, colour = Species))

as_vegaspec(plot)
```

]

???
vegawidget, an htmlwidget within the vegawidget GitHub organization, is used to render the specification created by ggvega. 

---
### ggvega + vlbuildr

.pull-left[

```{r eval=FALSE}
library("ggplot2")
library("ggvega")
library("vlbuildr")

plot <- ggplot(iris) + 
  geom_point(aes(x = Petal.Width, y = Petal.Length, 
                 colour = Species))

as_vegaspec(plot) %>%
vl_encode_fill("Species:N")

```

]

.pull-right[

```{r message=FALSE, warning=FALSE, echo=FALSE}
library("ggplot2")
library("ggvega")
library("vlbuildr")

plot <- ggplot(iris) + 
  geom_point(aes(x = Petal.Width, y = Petal.Length, colour = Species))

as_vegaspec(plot) %>%
vl_encode_fill("Species:N")
```

]

???
Once the Vega-Lite specification has been created, we can use vlbuildr, another package within the vegawidget GitHub organization, to modify the specification. vlbuildr is "a functional approach to building up specifications" and the package contains functions that can add various components to a specification.

---
### Add selections with vlbuildr!


???

With vlbuildr, we can add selections and conditional encodings without addressing this issue in ggvega/ggplot2.


---
class: inverse, center, middle
# Limitations

---
### Issues


---
### Mismatches


---
### Other limitations

---
class: inverse, center, middle
# Future Work

---
### Decisions, questions, etc.




---
### Roadmap

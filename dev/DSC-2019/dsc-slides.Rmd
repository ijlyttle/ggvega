---
title: "ggvega"
subtitle: "ggplot2 to Vega-Lite translator"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["default", "extra-theme.css"]
    nature:
      ratio: "16:9"
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
options(htmltools.dir.version = FALSE)
library(tidyverse)
library(htmltools)
library(ggvega)
library(vegawidget)
```

```{r setupmore, include=FALSE}
cars <- jsonlite::fromJSON("https://vega.github.io/vega-lite/data/cars.json")

set.seed(314)
n_obs <- 100

lang_prob <- tribble(
     ~language, ~probability,
           "R",         0.40,
      "Python",         0.30,
         "C++",         0.15,
  "JavaScript",         0.10,
        "Lisp",         0.05
)

data_all <- 
  tibble(
    user_id = seq(1, 2 * n_obs),
    language = 
      sample(
        lang_prob$language, 
        size = 2 * n_obs, 
        replace = TRUE, 
        prob = lang_prob$probability
    )
  )  

data_init <- data_all[data_all$user_id <= n_obs, ]
data_new <- data_all[data_all$user_id > n_obs, ]
```

### ggvega

Created to translate from ggplot2 to Vega-Lite  

- inspired by the capability `plotly::ggplotly()` provides 

.pull-left[

```{r echo=FALSE, fig.width=5, fig.height=4}
p <- ggplot(cars, aes(x = Horsepower, y = Miles_per_Gallon)) +
  geom_point(aes(color = Origin)) 

p
```
]
.pull-right[
```{r echo=FALSE, fig.asp=.65}
p <- ggplot(cars, aes(x = Horsepower, y = Miles_per_Gallon)) +
  geom_point(aes(color = Origin)) 

as_vegaspec(p)
```
]


.footnote[
This project has been supported by Iowa State University, Schneider Electric, and GSOC.
]

---
class: inverse, center, middle
# Motivation


---
### Build & deploy visual components 


A guiding principle for fundamental design choices was for the result to be extensible to new data.

<br/>

.center[

```{r echo=FALSE}
g <- ggplot(data_init, aes(x = language)) + geom_bar()

vs <- as_vegaspec(g)

vegawidget(vs, elementId = "vis")
```

```{r control, echo=FALSE}
control <- 
  tags$div(
    tags$span("dataset"),
    tags$select(
      name = "dataset",
      tags$option(value = "data_init", "Initial"),
      tags$option(value = "data_new", "New")
    )
  )

control
```


```{r data, echo=FALSE}
ser <- function(x) {
  x <- purrr::transpose(x)
  x <- jsonlite::toJSON(x, auto_unbox = TRUE)
  
  x
}

data_script <- 
  tags$script(
    type = "text/javascript",
    glue_js(
      "var data_all = {'data_init': ${ser(data_init)}, 'data_new': ${ser(data_new)}};"
    )
  )

data_script
```


```{js echo=FALSE}
// {js}
function on_data() {

  // get a local dataset
  var data_local = data_all[data_choice.value];
  
  // change Vega chart
  Vegawidget.findViewPromise('#vis').then(function(view) {
    var changeSet = vega.changeset()
                        .insert(data_local)
                        .remove(vega.truthy);
                          
    view.change('data-00', changeSet).run();  
  });  
}
```


```{js echo=FALSE}
// {js}
var data_choice = document.querySelector("[name=dataset]");

// whenever the input changes, run the updating function
data_choice.addEventListener("input", on_data);

// run the updating function *once* to initialize the input to the data
on_data();
```

]

???

---
### Build & deploy visual components


A guiding principle for fundamental design choices was for the result to be extensible to new data.  

This distinguishes this effort from `plotly::ggplotly()`

<br/>


> Compared to `plot_ly()`, statistical queries (client-side) with `ggplotly()` are fundamentally limited. That’s because, the statistical R functions that ggplot2 relies on to generate the graphical layers can’t necessarily be recomputed with different input data in your web browser.


---
### ggplot2 + interactivity

Our requirements for the JavaScript library:

  - has the grammar of graphics at its foundation  
  
  - is open source  
  
  - is easy to use  
  
  - is able to be linked with other preexisting htmlwidgets  
  
  - can be tied to ggplot2  

---
### Vega + Vega-Lite


Designed to be a visualization grammar that is built for analysis

Both Vega and Vega-lite use a JSON specification to create a visualization

An implementation of visualization terms with the **grammar of graphics** at its core

--
.center[
.salt[data  ].fat[  stat  ].acid[  mapping  ].heat[  geom]  
]
--
.center[
.salt[data  ].fat[  transform  ].acid[  encoding  ].heat[  mark  ]  
]
--
.center[
.salt[salt  ].fat[  fat  ].acid[  acid  ].heat[  heat]
]


---
### Motivating use-case for ggvega

A data-scientist designs a visualization using R with ggplot2  

The ggplot2 object is translated to a Vega-Lite specification (using ggvega)  

The Vega-Lite specification can be deployed to production, independently of the data used to design it. 

Vega provides the means to update Vega views with new data.


---
class: inverse, center, middle
# Design Philosophy

---
### Fundamental design choices


<br/>

**Our initial philosophy:** A narrow scope built on a firm foundation.

<br/>

**Design choice #1:** intention vs. implementation?

???

ggvega seeks to capture the *intent* of a ggplot. This is distinct from the *implementation* of a ggplot (the path `ggplotly()` takes). Our idea is to let the powerful defaults of the two packages take care of most of the work. In addition, we anticipated (at some point in the (hopefully not-too-)distant future) creating a Vega-lite theme for the visual components.

---
.salt[ggplot2 ].fat[ -> ].acid[ ggspec ].fat[ -> ].heat[ vlspec]

<br/>

#### A 2 step process:

1. Convert a ggplot2 object into a "ggspec", a JSON-serializable list  

2. Convert a "ggspec" into a Vega-Lite specification or "vegaspec".

<br/>

.center[

]

???

#### Why 2 steps? 

- We hope that the ggspec can be a useful abstraction to help us understand  "what is going on in ggplot2?" and "how does this intersect with Vega-Lite?". 

- Should ggplot2 or Vega-Lite change, we hope that we could keep ggspec "fixed" such that we would have to adapt only that part of the translation process (ggplot2-to-ggspec or ggspec-to-Vega-Lite) that would be impacted by such a change.

---
.salt[ggplot2 ].fat[ -> ].acid[ ggspec ]

<br/>

The ideas for "ggspec" are 

- to remain faithful to the ggplot2 object and philosophy

- to publish a JSON schema that represents the range of "things" that we will be able to translate

- to provide the means to generate a JSON specification that meets this schema, given a ggplot2 object

<br/>

???

The ggspec should record only those things that deviate from ggplot2 defaults; one should be able to take a ggspec and recreate the ggplot object that it came from.

Accordingly, we think to specify things in Vega-Lite only as they differ from the Vega-Lite defaults. Our goal is to capture the “essence” of the ggplot, its intentions, then to implement in a default Vega-Lite specification. To replicate the default color-maps and appearance, we recommend using a Vega theme (we hope to propose a better ggplot2-theme for Vega).




---
.salt[ggplot2 ].fat[ -> ].acid[ ggspec ]


.pull-left[

```{r fig.asp=.65}
p <- ggplot(cars, aes(x = Horsepower, y = Miles_per_Gallon)) +
  geom_point(aes(color = Origin)) 

p
```

]
.pull-right[


```{r eval=FALSE}
ggvega::gg2spec(p)
```

```json
{
  "data": {
    "data-00": {
      "metadata": {},
      "observations": []
    }
  },
  "layers": [
    {
      "data": "data-00",
      "geom": {},
      "geom_params": {},
      "mapping": {},
      "aes_params": {},
      "stat": {},
      "stat_params": {},
      "position": {}
    }
  ],
  "scales": [],
  "labels": {},
  "coordinates": {},
  "facet": {}
}
```
]

---


.left-minus-tall[
<br/>
<img src="dsc_files/ideal_vs_real.jpg" width="400"> 
]
.right-plus-tall[
### Idealized vs. Actualized

**Idealized version:**   
- a JSON-serializable representation of any possible ggplot object;  

- that it could also be a loss-less representation of any ggplot object.  

**Actualized version:**
- *is* a JSON-serializable representation of a ggplot object that we can translate into Vega-Lite.

<!--
In an ideal world, we might have taken on the **idealized** ggspec, then defined an **actualized** subset. 

However, in the interests of "getting something done", we considered briefly the first possibility, then went straight for the second possibility. 

-->

]

---
.acid[ ggspec ].fat[ -> ].heat[ vlspec]

<br/>

The ggspec is then converted into a vegaspec. 

As a first approach, we took inspiration from Vega-Lite itself, which translates a Vega-Lite specification into a Vega specification. 

This compiler is developed in TypeScript, then compiled into ECMAScript 6 (JavaScript), as described in the [Vega-Lite contribution guide](https://github.com/vega/vega-lite/blob/master/CONTRIBUTING.md#suggested-programming-environment).


---
.acid[ ggspec ].fat[ -> ].heat[ vlspec]

.pull-left[


```{r eval=FALSE}
ggvega::gg2spec(p)
```

```json
{
  "data": {
    "data-00": {
      "metadata": {},
      "observations": []
    }
  },
  "layers": [
    {
      "data": "data-00",
      "geom": {},
      "geom_params": {},
      "mapping": {},
      "aes_params": {},
      "stat": {},
      "stat_params": {},
      "position": {}
    }
  ],
  "scales": [],
  "labels": {},
  "coordinates": {},
  "facet": {}
}
```
]
.pull-right[
```{r eval = FALSE}
ggvega::as_vegaspec(p)
```


```json
{
  "$schema": "https://vega.github.io/schema/vega-lite/v3.json",
  "datasets": {
    "data-00": []
  },
  "layer": [
    {
      "data": {},
      "mark": {},
      "encoding": {
        "x": {},
        "y": {},
        "stroke": {}
      }
    }
  ]
}
```
]


---
class: inverse, center, middle
# Examples

---
### ggvega


.pull-left[

```{r eval=FALSE}
library("ggplot2")
library("ggvega")


plot <- ggplot(iris) + 
  geom_point(aes(x = Petal.Width, y = Petal.Length, 
                 colour = Species))

as_vegaspec(plot)
  

```

]

.pull-right[

```{r message=FALSE, warning=FALSE, echo=FALSE}
library("ggplot2")
library("ggvega")
plot <- ggplot(iris) + 
  geom_point(aes(x = Petal.Width, y = Petal.Length, colour = Species))

as_vegaspec(plot)
```

]

???
vegawidget, an htmlwidget within the vegawidget GitHub organization, is used to render the specification created by ggvega. 

---
### ggvega + vlbuildr

.pull-left[

```{r eval=FALSE}
library("ggplot2")
library("ggvega")
library("vlbuildr")

plot <- ggplot(iris) + 
  geom_point(aes(x = Petal.Width, y = Petal.Length, 
                 colour = Species))

as_vegaspec(plot) %>%
vl_encode_fill("Species:N")

```

]

.pull-right[

```{r message=FALSE, warning=FALSE, echo=FALSE}
library("ggplot2")
library("ggvega")
library("vlbuildr")

plot <- ggplot(iris) + 
  geom_point(aes(x = Petal.Width, y = Petal.Length, colour = Species))

as_vegaspec(plot) %>%
vl_encode_fill("Species:N")
```

]

???
Once the Vega-Lite specification has been created, we can use vlbuildr, another package within the vegawidget GitHub organization, to modify the specification. vlbuildr is "a functional approach to building up specifications" and the package contains functions that can add various components to a specification.

---
### Add selections with vlbuildr!


???

With vlbuildr, we can add selections and conditional encodings without addressing this issue in ggvega/ggplot2.


---
class: inverse, center, middle
# Limitations

---
### Issues: ES5 & ES6

- ES6 is supported by all modern browsers, except, the last version of IE supports only ES5.  

- The V8 package supports ES6 for all platforms, except some older Linux platforms  
  - e.g. Ubuntu 16.04 (RStudio Cloud)

#### Conclusions

- We chose to write code that can be run on an ES5 JavaScript engine; however, as of version 3.0, Vega-Lite is written using ES6

- If we had complete support for ES6, we could use the Vega-Lite classes to be converted into a schema.

- Instead, we use "quicktype" to recover a set of Vega-Lite classes using the Vega-Lite schema, but they are not identical to the Vega-Lite classes

- This "problem" will go away when we have sufficuent ES6 coverage for V8, or when we are able to recover faithfully the Vega-Lite classes in R.

???

The Vega-Lite team have made a tool to convert JavaScript classes into a schema; we use this to create ggschema from classes. We also need a way to recover the Vega-Lite classes from the schema. If we had complete support for ES6, we could use the Vega-Lite classes themselves. 

Instead, because we have to use ES5, we use a JavaScript library called "quicktype" to recover a set of Vega-Lite classes using the Vega-Lite schema. However, the "recovered" classes from the schema are not identical to the Vega-Lite classes. This might be a little bit like a translating from English to French, then back to English, recovering different prose.

This leads to quicktype giving some "Vega-Lite" classes some strange names due to its interpretation of the schema.

This "problem" will go away when we have sufficuent ES6 coverage for {V8}, or when we are able to recover faithfully the Vega-Lite classes in R.

---
### Mismatches

`geom_path()` is based on the order of the data vs. in Vega-Lite there is an order encoding  

`positionDodge` and `positionJitter`  
- Vega-Lite is working on implementing this (PR: vega/vega-lite#4969)

The ordering of ordered factors and being extensible to new data. 
- ex. bar chart of populations of cities  
  - In ggplot2, use forcats package to order according to population size 
  - We cannot capture this because it happens outside the ggplot object
  - Can we use (or create?) a `stat_order()` to do this??

---
### Other limitations

#### Expressions + aesthetic mappings:
- We are *very* restrictive on the expressions we will allow for aesthetic mappings in ggplot. 
- We currently support variable-names only; the only foreseeable exception to this will be to manage factors.

#### Temporal values:
- In R, a `POSIX.ct` object has access to a timezone database via the operating system.  
- In JavaScript, a `Date` object has access only to the timezone of the browser and UTC.  
- The Vega-Lite `temporal` type is based on the JavaScript `Date` type, so its access to timezone information is similarly limited. 

#### Interactions/Selections: 
- There is a lot of flexibility in specifying interactions (which is good), but not a lot of support for signifying the presence of interactivity or showing how it is expected to work. This is an area where Plotly has an advantage.  
- Related, Vega-Lite selections do not work well on mobile devices.

???


This becomes a problem if the timezone of the data does not match the timezone of the browser; this would not be an uncommon situation. 

There are workarounds, but they involve compromises.

---
class: inverse, center, middle
# Future Work

---
### Decisions, questions, etc.

#### Should the transformations take place in R or put into the Vega-lite specification?

**Option 1:** If the Vega-Lite spec does an aggregate, do the aggregation in R instead of JS so that the resulting htmlwidget has a much smaller data set. 

**Option 2:** Have the output (the Vega-Lite specification) act as a component so that we can the change different data sets in and out of the Vega-Lite specification only.

<br/>

#### Can we write a specification such that the transformation is done *somewhere*?

- a remote R session (using Shiny)
- a remote SQL database 
- the JavaScript client (the browser itself)

???

Then the questions could become:  

- How do we write the Vega(-Lite) specification such that the transformation could be done anywhere?  
- Given a Vega-Lite specification, how to we implement the transformation so that it will be made at a given place?  


---
### What we can do now + what we will do next

#### What we can do now:

- `geom_point()` and `geom_bar()`
- `stat_count()`
- `position_stack()` and `position_fill()`
- `coord_flip()`
- labels
- extract name from scales
- if we have a single-layer ggplot object, we can create a single-view Vega-Lite specification

#### What we will take on next:

- `stat_bin()`, enabling histograms
- `geom_line()`
- `facet_grid()` and `facet_wrap()`
- `geom_boxplot()` (`stat_boxplot()`)
- scales (this will be an undertaking)
- a framework to handle temporal values (another undertaking)


---
### New features on the horizon


New to Vega-Lite 4.0 (currently in beta):

- [regression](https://vega.github.io/vega-lite/docs/regression.html)
- [loess](https://vega.github.io/vega-lite/docs/loess.html)
- [density](https://vega.github.io/vega-lite/docs/density.html)


As these new capabilities are released in Vega-Lite:

- `geom_smooth()`
- `geom_density()`
- `position_dodge()` and `position_jitter()`

